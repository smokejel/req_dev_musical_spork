#!/usr/bin/env python3
"""
Generate visual diagrams of the LangGraph workflow structure.

This script uses LangGraph's built-in visualization capabilities to generate
Mermaid diagram code that can be rendered in documentation, GitHub, or online
at mermaid.live.

Usage:
    python scripts/visualize_graph.py

Output:
    - docs/workflow_graph.md (Mermaid diagram in markdown format)
"""

from pathlib import Path
import sys

# Add project root to path for imports
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from src.graph import create_decomposition_graph


def generate_mermaid_visualization(output_file: str = "docs/workflow_graph.md") -> None:
    """
    Generate Mermaid diagram syntax and save to markdown file.

    Args:
        output_file: Path to output markdown file
    """
    print("üîÑ Generating workflow graph visualization...")

    try:
        # Create the decomposition graph
        graph = create_decomposition_graph()

        # Generate Mermaid syntax using LangGraph's built-in method
        mermaid_code = graph.get_graph().draw_mermaid()

        # Create markdown content with diagram and documentation
        markdown_content = f"""# Requirements Decomposition Workflow Graph

This diagram shows the LangGraph workflow structure for the requirements decomposition system.

## Workflow Nodes

1. **extract** - RequirementsAnalystAgent
   - Model: Gemini 2.5 Flash-Lite
   - Purpose: Parse specification documents and extract high-level requirements

2. **analyze** - SystemArchitectAgent
   - Model: Claude Sonnet 3.5
   - Purpose: Understand system context and create decomposition strategy

3. **decompose** - RequirementsEngineerAgent
   - Model: GPT-5 Nano
   - Purpose: Break down requirements into detailed, testable specifications

4. **validate** - QualityAssuranceAgent
   - Model: Gemini 2.5 Flash
   - Purpose: Score quality and enforce quality gates

5. **human_review** - Interactive CLI
   - Purpose: Human-in-the-loop review and feedback

6. **document** - Output Generator
   - Purpose: Generate final documentation and traceability matrices

## Workflow Features

- **Conditional Routing:** Flow adapts based on review flags and validation results
- **Iterative Refinement:** Validation failures trigger decomposition retry with feedback
- **Human-in-the-Loop:** Optional pre-decomposition and mandatory post-validation review
- **Quality Gates:** 0.80 threshold (configurable) with max 3 iterations

## Diagram

```mermaid
{mermaid_code}
```

## How to View This Diagram

### Online (Easiest)
1. Copy the Mermaid code block above
2. Visit https://mermaid.live
3. Paste the code into the editor
4. The diagram will render interactively

### GitHub/GitLab
This file will render automatically when viewed on GitHub or GitLab.

### VS Code
Install the "Markdown Preview Mermaid Support" extension to view diagrams in preview mode.

### Mermaid CLI (Local Rendering)
```bash
# Install Mermaid CLI
npm install -g @mermaid-js/mermaid-cli

# Generate PNG from this file
mmdc -i docs/workflow_graph.md -o docs/workflow_graph.png
```

## Workflow Routing Logic

### After Analyze Node
- **If `review_before_decompose = True`:** ‚Üí human_review ‚Üí decompose
- **If `review_before_decompose = False`:** ‚Üí decompose (direct)

### After Validate Node
- **If validation passes:** ‚Üí document ‚Üí END
- **If validation fails and iterations < max:** ‚Üí decompose (with refinement feedback)
- **If validation fails and iterations >= max:** ‚Üí human_review

### After Human Review Node
- **If human approves:** ‚Üí document ‚Üí END
- **If human requests revisions:** ‚Üí decompose (with human feedback)
- **If human requests decompose:** ‚Üí decompose

## State Persistence

The workflow uses SQLite checkpointing to persist state between runs, allowing:
- Resume interrupted workflows
- Inspection of intermediate states
- Recovery from failures

---

*Generated by `scripts/visualize_graph.py` using LangGraph's built-in visualization*
"""

        # Ensure docs directory exists
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write markdown file
        output_path.write_text(markdown_content)

        print("‚úÖ Mermaid diagram generated successfully!")
        print(f"‚úÖ Saved to: {output_file}")
        print()
        print("üìä View the diagram:")
        print("  ‚Ä¢ Online: Copy code to https://mermaid.live")
        print("  ‚Ä¢ GitHub: View docs/workflow_graph.md in repository")
        print("  ‚Ä¢ Local: Use Mermaid CLI or VS Code extension")
        print()

        # Print diagram statistics
        node_count = mermaid_code.count("([")
        edge_count = mermaid_code.count("-->")
        print(f"üìà Diagram statistics:")
        print(f"  ‚Ä¢ Nodes: {node_count}")
        print(f"  ‚Ä¢ Edges: {edge_count}")
        print()

    except Exception as e:
        print(f"‚ùå Error generating visualization: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


def main():
    """Main entry point."""
    print("=" * 70)
    print("  Requirements Decomposition Workflow - Graph Visualization")
    print("=" * 70)
    print()

    generate_mermaid_visualization()

    print("‚ú® Visualization complete!")
    print()


if __name__ == "__main__":
    main()
